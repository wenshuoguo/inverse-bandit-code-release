"""
4-step policy simulator

INPUTS:
    -C1, C2, C3: C rate parameters (C4 is calculated)
    -mode: 'lo','med','hi'. Three different landscapes
    -variance: Include cell-to-cell variation

OUTPUT: Lifetime
"""

import math
import random
import numpy as np
import sys
import argparse

def sim(C1, C2, C3, mode='hi', variance=True, seed=0):
    
    random.seed(seed*1000+C1*10+C2*20+C3*30) # deterministic for the same seed

    # STANDARD DEVIATION
    if variance:
        sigma = 164 # Sampling variation + prediction error. Estimated from batch8
    else:
        sigma = 0

    # DETERMINE C4
    C4 = 0.2/(1/6 - (0.2/C1 + 0.2/C2 + 0.2/C3))
    
    # CONSTANT PARAMETERS
    R = 0.009              # [=] m, radius of 18650 cylindrical cell
    L = 0.065              # [=] m, length of 18650 cylindrical cell
    R_int = 0.017          # [=] Ohms, internal resistance
    Tinit = 30             # [=] deg C, initial temperature
    Tinf  = 30             # [=] deg C, environmental temperature
    V = math.pi * R**2 * L # [=] m^3, cell volume

    # ESTIMATED PARAMETERS
    # Values for k, Cp, and rho from Drake et al, JPS (2014)
    # http://www.uta.edu/faculty/jaina/MTL/pubs/Drake-JPS2014.pdf
    k = 0.20   # [=] W/m-K, thermal conductivity
    Cp = 1000  # [=] J/kg-K, specific heat capacity
    rho = 2362 # [=] kg/m^3, density

    # Value for rho estimated from mass of cell is in good agreement with above
    # value
    # http://www.a123batteries.com/v/vspfiles/images/pdf/APR18650M1A.pdf
    # rho = (39/1000)/V # [=] kg/m^3, average density

    # Value for h taken from Engineering Toolbox: h = 10 for air, 500 for oil
    h = 10 # [=] W/m^2-K, heat transfer coefficient

    # DEGRADATION PARAMETERS. ESTIMATED FROM SMITH, DAHN ET AL 2011
    if mode == 'lo':
        A = 5e21      # [=] 1/s, pre-exponential constant
        Ea = 0.25    # [=] eV, activation energy
    elif mode == 'med':
        A = 4      # [=] 1/s, pre-exponential constant
        Ea = 0.10    # [=] eV, activation energy
    elif mode == 'hi':
        A = 136      # [=] 1/s, pre-exponential constant
        Ea = 0.122    # [=] eV, activation energy
    else:
        print('Mode not recognized. Please use ''lo'',''med'', or ''high''.')
    kb = 8.617E-5 # [=] eV/K, Boltzmann's constant

    # CALCULATED PARAMETERS
    I1 = C1*1.1             # [=] A, C1 discharge current
    I2 = C2*1.1             # [=] A, C2 discharge current
    I3 = C3*1.1             # [=] A, C1 discharge current
    I4 = C4*1.1             # [=] A, C2 discharge current
    Qn = 1.1*20/100       # [=] Ah, capacity filled during one step
    t1 = Qn / I1 * 3600     # [=] s, time of C1
    t2 = Qn / I2 * 3600     # [=] s, time of C2
    t3 = Qn / I3 * 3600     # [=] s, time of C3
    t4 = Qn / I4 * 3600     # [=] s, time of C4
    #total_time = t1 + t2 + t3 + t4;   # [=] s, total time for both C1 and C2 steps
    alpha = k/(rho*Cp)      # [=] m^2/s, thermal diffusivity
    power1 = I1**2 * R_int  # [=] W, power generated by cell during C1
    e_gen1 = power1 / V     # [=] W/m^3, volumetric heat generation term
    power2 = I2**2 * R_int  # [=] W, power generated by cell during C2
    e_gen2 = power2 / V     # [=] W/m^3, volumetric heat generation term
    power3 = I3**2 * R_int  # [=] W, power generated by cell during C3
    e_gen3 = power3 / V     # [=] W/m^3, volumetric heat generation term
    power4 = I4**2 * R_int  # [=] W, power generated by cell during C4
    e_gen4 = power4 / V     # [=] W/m^3, volumetric heat generation term

    """"
    --------------------------BEGIN SIMULATION--------------------------
    """

    ## Set up problem
    dr = 0.001 # [=] m, length step
    dt = 20    # [=] s, time step. <2s for minimal error, 5s is reasonable

    N = int(np.round(R/dr + 1))
    r = np.arange(-dr,R+2*dr,dr)
    T = Tinit*np.ones((N+2,1)) # initialize domain to be IC
    #T[N+1,0] = T[N,0]-dr*k*h*(T[N,0]-Tinf) # Env. boundary condition


    # PRE-INITIALIZE VARIABLES
    time = 0
    deg_rates = 0

    def fin_el(Tin, e_gen):
        # FINITE ELEMENT SIMULATION
        mat = np.zeros((N+2,N+2))
        rhs = np.zeros((N+2,1))

        # Internal domain
        for i in np.arange(2,N+1):
            mat[i,i] = (r[i] * dr**2 * dt) * (1/(alpha*dt)+2/(dr**2))
            mat[i,i+1] = (r[i] * dr**2 * dt) * (-1/(2*r[i]*dr)-1/(dr**2))
            mat[i,i-1] = (r[i] * dr**2 * dt) * (1/(2*r[i]*dr)-1/(dr**2))
            rhs[i] = (r[i] * dr**2 * dt) * ( Tin[i,0]/(alpha*dt)+e_gen/k )

        # Boundary condition at r = 0
        mat[0,0] = 1
        mat[0,2] = -1

        # Cartesian singularity at r = 0
        mat[1,1] = (dr ** 2 * dt) * (4/(dr**2))
        mat[1,2] = (dr ** 2 * dt) * ((1/dt - 4/(dr**2)))
        rhs[1]   = (dr ** 2 * dt) * (Tin[1,0]/(dt) + e_gen/k)

        # Boundary condition at r = R
        mat[N+1,N] = -h
        mat[N+1,N+1] = -k/(2*dr)
        mat[N+1,N-1] = k/(2*dr)
        rhs[N+1] = -h*Tinf

        return np.linalg.lstsq(mat, rhs, rcond=None)[0] # T(r)

    ## C1 step
    while time < t1:

        T = fin_el(T, e_gen1)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## C2 step
    while time < t1 + t2:
        T = fin_el(T, e_gen2)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))
            
    ## C3 step
    while time < t1 + t2 + t3:

        T = fin_el(T, e_gen3)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))
            
    ## C4 step
    while time < t1 + t2 + t3 + t4:

        T = fin_el(T, e_gen4)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))
    
    # arbitrary factor to give lifetimes on the order of 100s of cycles
    if mode == 'lo':
        lifetime_true = int(1/deg_rates/1e10) + 900
    elif mode == 'med':
        lifetime_true = int(1/deg_rates/4e9) + 900
    elif mode == 'hi':
        lifetime_true = int(1/deg_rates/2e10) + 500
    lifetime_meas = int(random.gauss(lifetime_true, sigma))
    if lifetime_meas < 0: lifetime_meas = 1
    # print("Lifetime = " + str(lifetime_meas))
    return lifetime_meas


def parse_args():

    parser = argparse.ArgumentParser(description='Simulator for battery lifetime')
    parser.add_argument('--C1', default=1, type=float,
                        help='constant current 1')
    parser.add_argument('--C2', default=1, type=float,
                        help='constant current 2')
    parser.add_argument('--C3', default=1, type=float,
                        help='constant current 3')
    parser.add_argument('--seed', default=1, type=float,
                        help='seed')
    return parser.parse_args()


def main():

    args = parse_args()
    lifetime = sim(args.C1, args.C2, args.C3, seed=args.seed)
    print('Simulated lifetime is', lifetime)


if __name__ == '__main__':

    main()
